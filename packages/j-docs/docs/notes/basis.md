
[toc]

# 计算机基础

## 计算机计量单位

### 比特（位）

二进制中最小的单位，每个比特（位）的值要么是`0`要么是`1`

### 字节

通常`8`个比特构成一个字节

### 8位字节

`8`个比特也被称为`8位字节`，只有为了强调`1个字节`中包含`8个比特`时才会使用


## 网络

### 网络分类

| 网络作用范围分类|  范围 | 区域
|------------ | --- | --- |
| 广域网（`WAN`） | 几十到几千公里 | 跨省,跨国 |
| 城域网（`MAN`） | 5KM-50KM |  城市间 |
| 局域网（`LAN`） | 1KM以内 | 地区内 |

| 网络使用者分类 |
| ------- |
| 公用网络 |
| 专用网络 |

### 网络模型

| 计算机网络层次结构设计的基本原则 |
| -------- |
| 各层之间是相互独立的 |
| 每一层要有足够的灵活性 |
| 各层之间完全解耦 |

| OSI七层模型 |  目的 |
| ------ | ----- |
| 应用层 | 为计算机用户提供接口和服务 |
| 表示层 | 数据处理（编码解码，加密解密等）
| 会话层 | 管理（建立，维护，重连）通信会话|
| 传输层 |  管理端到端的通信连接 |
| 网络层 | 数据路由（决定数据在网络的路径） |
| 数据链路层 | 管理相邻节点之间的数据通信 |
| 物理层 | 数据通信的光电物理特性 |

| TCP/IP四层模型 |
| ----- |
| 应用层 |
| 传输层 |
| 网络层 |
| 网络接口层 |

### 网络速率

`bps = bit/s`

#### 为什么电信拉的100M光纤，测试峰值速度只有12M每秒？

```
100M/s = 100Mbps = 100Mbit/s
100Mbit/s = (100/8)MB/s = 12.5MB/s
```

### 物理层

物理层主要`连接不同的物理设备`，`传输比特流`



### 数据链路层

数据链路层主要解决三个问题，`封装成帧`，`透明传输`，`差错监测`


#### 封装成帧

`帧`是数据链路层的基本单位，数据链路层会将数据的首部和尾部加上特定标记形成`帧`，`帧首部`是特定的`控制字符（SOH：00000001）`，`帧尾部`是特定的`控制字符（EOT：00000100）`

#### 透明传输

`帧数据`里面如果有`控制字符（SOH和EOT）`，就需要`透明传输`，对数据中的`控制字符`进行特殊处理，在`控制字符`的前面加上一个`转译字符`，如果数据里也出现了`转译字符`，就在前面在加上一个`转译字符`

#### 差错监测

因为物理层只负责传输，无法控制是否出错，如果在数据传输中出错了，就需要用到`差错监测`。`差错监测`利用`循环冗余校验码CRC`（一种根据传输或保存的数据而产生固定位数校验码的方法），检测数据传输或者保存后可能出现的错误。

发送端根据`CRC`计算出可校验的位串后，就可以把`比特流`发送给接收端，接收端在接收到`比特流`之后，将接收到的数据除以`G（x）`的位串，根据余数判断是否出错。如果余数是`0`则没有出错，否则就出错了。不过数据链路层只进行数据的检测，不进行纠正。


##### 循环冗余校验码CRC计算规则


选定一个用于校验的多项式`G（x）`，并在数据尾部添加`r个0`
将添加`r个0`后的数据，使用`模2除法`除以多项式的位串
得到的`余数`填充在原数据`r个0`的位置，得到可校验的位串


###### 使用CRC计算101001的可校验位串

G（x） = x<sup>3</sup> + x<sup>2</sup> + 1
G（x）= 1 * x<sup>3</sup> + 1 *  x<sup>2</sup> + 0 * x<sup>1</sup> + 1 * x<sup>0</sup>
G（x）的二进制位串是`1101`，最高阶为`3`
所以在数据尾部添加`r个0`，这个`r`就是`3`，添加后得到`101001000`
`101001000/1101`得到余数`001`，将余数填充在原数据`r个0`的位置，得到 `101001001`


###### 使用CRC计算10110011的可校验位串

G（x） = x<sup>4</sup> + x<sup>3</sup> + 1
G（x）= 1 * x<sup>4</sup> + 1 *  x<sup>3</sup> + 0 * x<sup>2</sup> + 0 * x<sup>1</sup> + 1 * x<sup>0</sup>
G（x）的二进制位串是`11001`，最高阶为`4`
所以在数据尾部添加`r个0`，这个`r`就是`4`，添加后得到 `101100110000`
`101100110000/11001`得到余数`0100`，将余数填充在原数据`r个0`的位置，得到 `101100110100`



#### MTU

`MTU`是数据链路层最大传输单元。以太网`MTU`一般为1500字节。`路径MTU`由链路中`MTU`的最小值决定

#### MAC地址

每一个设备都拥有唯一的`MAC地址`，`MAC地址`共`48位`，使用`十六进制`表示


#### 以太网协议


以太网是一种使用广泛的局域网技术，是一种应用与数据链路层的协议

根据以太网协议。A电脑想传输数据到C电脑，首先A通过网卡发出`数据帧`，`数据帧`到达路由器，路由器取出前6字节，前6字节是`目的地址`，路由器查询`MAC地址表`找到对应的网络接口并发送`数据帧`


##### 以太网数据格式



| 目的地址 | 源地址 | 类型 | 帧数据 | CRC |
| ----- | ----- | ----- | ---- | ----|
| 6B | 6B | 2B | 46B-1500B | 4B |




### 网络层

#### IP协议

`IP协议`使得复杂的实际网络变为一个虚拟互联的网络
`IP协议`使得网络层可以屏蔽底层细节而专注网络层的数据转发
`IP协议`解决了在虚拟网络中数据包传输路径的问题

IP地址长度为32位，常分成4个8位
IP地址常使用`点分十进制`来表示（0-255.0-255.0-255.0-255）


##### IP数据报

`IP数据报`分为`IP首部`,`IP数据报的数据`两部分

<table>
    <thead>
        <tr>
           <th colspan="6">IP首部</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>版本(4位)</td>
            <td>首部长度(4位)</td>
            <td>服务类型（TOS）(8位)</td>
            <td colspan="3">总长度（字节）(16位)</td>
        </tr>
        <tr>
            <td colspan="4">标识(16位)</td>
            <td>标志(3位)</td>
            <td>片偏移(13位)</td>
        </tr>
        <tr>
            <td colspan="2">生存时间（TTL）(8位)</td>
            <td>协议(8位)</td>
            <td colspan="3">首部校验和(16位)</td>
        </tr>
        <tr>
            <td colspan="6">源IP地址(32位)</td>
        </tr>
        <tr>
            <td colspan="6">目的IP地址(32位)</td>
        </tr>
        <tr>
            <td colspan="6">选项options（若有）</td>
        </tr>
        <tr>
            <td colspan="6">IP数据</td>
        </tr>
    </tbody>
</table>


版本：占4位，指的是IP协议的版本，通信双方的版本必须一致，当前主流版本是4，即IPv4，也有IPv6

首部长度：占4位，最大数值为15，表示的是IP首部长度，IP首部最大长度为60字节

总长度：占16位，最大数值为65535，表示的是IP数据报总长度（IP首部+IP数据）

生存时间（TTL）：占8位，表明IP数据报文在网络中的寿命，每经过一个设备，TTL减1，当TTL=0时，网络设备必须丢弃该报文

协议：占8位，表明IP数据所携带的具体数据是什么协议的（如：TCP，UDP等）

首部校验和：占16位，校验IP首部是否有出错

##### IP协议的转发流程

在IP协议转发流程中
数据帧每一跳的MAC地址都在变化
IP数据报每一跳的IP地址始终不变


```
graph TD
    A计算机-->E路由器
    E路由器-->D计算机
    E路由器-->F路由器
    F路由器-->C计算机
    F路由器-->B计算机
```
如果想将A计算机的数据发送到C计算机

> 只考虑网络层

A发出目的地为C的IP数据报，查询路由表发现下一跳为E
A将数据报发送给E
E查询路由表发现下一跳为F，将数据报发送给F
F查询路由表发现目的地C直接连接，将数据报发送给C

> 网络层和数据链路层结合

A发出目的地为C的IP数据报，查询路由表发现下一跳为E
A将IP数据报交给数据链路层，并告知目的MAC地址是E
数据链路层填充源MAC地址A和目的MAC地址E
数据链路层通过物理层将数据发送给E

E的数据链路层接收到数据帧，把帧数据交给网络层
E查询路由表，发现下一跳为F
E把数据报交给数据链路层，并告知目的MAC地址为F
E的数据链路层封装数据帧并发送

F的数据链路层接收到数据帧，把帧数据交给网络层
F查询路由表，发现下一跳为C
F把数据报交给数据链路层，并告知目的MAC地址为C
F的数据链路层封装数据帧并发送


###### 路由表

计算机或者路由器都拥有路由表

| 目的IP地址 | 下一跳IP地址 |
| ------- | ------- |
|  IP1 |  IP4 |
| IP2 | IP5 |
| IP3 | IP6 |
| ... | ... |


##### IP地址的子网划分

###### 分类的IP地址

|网络号 | 主机号 |  分类 |  网络号开头 |
| ---- | ---- | --- | ------ |
| 8位 | 24位 | A类地址 |  以0开头 |
| 16位 | 16位 | B类地址 | 以10开头 |
| 24位 | 8位 | C类地址 | 以110开头 |

> 特殊的主机号

1.主机号全0表示当前网络段，不可分配为特定主机
2.主机号全1表示广播地址，向当前网络段所有主机发消息

> 特殊的网络号

1.A类地址网络段全0（00000000）表示特殊网络
2.A类地址网络段后7位全1（01111111:127）表示回环地址
3.B类地址网络段（10000000.00000000:128.0）是不可使用的
4.C类地址网络段（192.0.0）是不可使用的




###### 划分子网

目的是节省IP资源 

| 网络号 | 子网号 | 主机号 |
|  ---- | ----- | ---- |

例：
193.10.10.0是一个C类地址，它有254个主机号，我们可以把第25位，看成是子网号，这样可以分为1和0这两个子网号，对于0这个子网号表示的IP地址范围是193.10.10.0-193.10.10.127,对于1这个子网号表示的IP地址范围是193.10.10.128-193.10.10.255

###### 子网掩码

通过子网掩码我们可以快速的判断某一个IP是属于哪一个网络号的

子网掩码和IP地址一样，都是32位但是子网掩码由连续的1和连续的0组成
某一个子网的子网掩码具备网络号位数个连续的1


|网络号 | 主机号 |  分类 |  网络号开头 |网络号的子网掩码 | 主机号的子网掩码 | 子网掩码 |
| ---- | ---- | --- | ------ | ----- | ---- | ----|
| 8位 | 24位 | A类地址 |  以0开头 | 11111111 | 000000000000000000000000| 255.0.0.0 | 
| 16位 | 16位 | B类地址 | 以10开头 | 1111111111111111 | 0000000000000000 | 255.255.0.0 |
| 24位 | 8位 | C类地址 | 以110开头 | 111111111111111111111111 | 00000000 | 255.255.255.0 |

例：
还以之前193.10.10.0这个IP为例，通过子网划分，分为193.10.10.0-193.10.10.127和193.10.10.128-193.10.10.255，我们可知193.10.10.0的子网掩码为255.255.255.128，现在有一个IP为193.10.10.6，把它和子网掩码换为二进制做"&"运算，最后得到结果是193.10.10.0（这个就是193.10.10.6的子网号），就快速判断出是属于哪一个网络号的




###### 无分类编址CIDR

CIDR中没有A，B，C类网络号和子网划分的概念
CIDR将网络前缀相同的IP地址称为一个`CIDR地址块`

| 网络前缀（任意位数的） | 主机号 |
| ----- | ---- |



#### ARP协议（Address Resolution Protocol）

作用

```
graph TB
网络层IP32位地址--> |ARP协议| 数据链路层MAC48位地址
```


ARP缓存表（缓存了IP地址到硬件地址之间的映射关系）
ARP协议是直接封装到数据链路层`帧数据`里面的

| IP地址 | MAC地址 |
| ---- | ----- |
| 192.168.83.254 | 00-50-56-e0-33-40 |
| 192.168.83.255 | 01-00-5e-00-00-16 |


数据格式

|类型（0806） | ARP请求/应答 | PAD |
| --- | ---- | ---- |
| 2 | 28 | 18 |

<table>
    <thead>
        <tr>
            <th colspan="7">ARP请求/应答(共28个字节)</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>硬件类型</td>
            <td>协议类型</td>
            <td>标记</td>
            <td>发送端以太网地址</td>
            <td>发送端IP地址</td>
            <td>目的端以太网地址</td>
            <td>目的端IP地址</td>
        </tr>
        <tr>
            <td>2</td>
            <td>2</td>
            <td>4</td>
            <td>6</td>
            <td>4</td>
            <td>6</td>
            <td>4</td>
        </tr>
    </tbody>
</table>


#### RARP协议（Reverse Address Resolution Protocol）

作用
```
graph TB
数据链路层MAC48位地址--> |RARP协议| 网络层IP32位地址
```

数据格式

|类型（8035） | RARP请求/应答 | PAD |
| --- | ---- | ---- |
| 2 | 28 | 18 |


#### 网络地址转换NAT（Network Address Translation）技术

NAT技术用于多个主机通过一个公有IP访问互联网的私有网络中
NAT减缓了IP地址的消耗，但是增加了网络通信的复杂度

IP地址分为两类，内网地址和外网地址

| 内网地址 | 外网地址 |
| ----- | ----- |
| 内部机构使用 | 全球范围使用 |
| 避免与外网地址重复 | 全球公网唯一 |


| 内网地址分三类 |
| ------ |
| 10.0.0.0-10.255.255.255(支持千万数量级设备)|
| 172.16.0.0-172.31.255.255(支持百万数量级设备)| 
| 192.168.0.0-192.168.255.255(支持万数量级设备)|

| 方向 | 旧的地址和端口号 | 新的地址与端口号 |
| --- | -------| ------ |
| 出 | 192.168.2.11:6666 | 173.21.59.10:16666 |
| 入 | 173.21.59.10:16666 | 192.168.2.11:6666 |

 
#### ICMP协议（Internet Control Message Protocol）

ICMP协议可以报告传输中错误信息或者异常情况，是封装在IP的数据报里面的

<table>
    <thead>
        <tr>
            <th colspan="2">IP数据报的数据</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>ICMP报文首部</td>
            <td>ICMP报文数据</td>
        </tr>
    </tbody>
</table>

<table>
    <thead>
        <tr>
            <th>8位类型</th>
            <th>8位代码</th>
            <th>16位校验和</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="3">ICMP报文数据</td>
        </tr>
    </tbody>
</table>


##### ICMP报文种类


<table>
    <thead>
        <tr>
            <th>ICMP报文种类</th>
            <th>类型的值</th>
            <th>报文类型</th>
            <th>具体代码</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="7">差错报告报文</td>
            <td rowspan="2">3(终点不可达)</td>
            <td>网络不可达</td>
            <td>0</td>
        </tr>
        <tr>
            <td>主机不可达</td>
            <td>1</td>
        </tr>
        <tr>
            <td rowspan="2">5(重定向)</td>
            <td>对网络重定向</td>
            <td>0</td>
        </tr>
        <tr>
            <td>对主机重定向</td>
            <td>1</td>
        </tr>
        <tr>
            <td>11</td>
            <td>传输超时</td>
            <td>-</td>
        </tr>
        <tr>
            <td rowspan="2">12</td>
            <td>坏的IP头</td>
            <td>0</td>
        </tr>
        <tr>
            <td>缺少其他必要参数</td>
            <td>1</td>
        </tr>
    </tbody>
</table>


<table>
    <thead>
        <tr>
            <th>ICMP报文种类</th>
            <th>类型的值</th>
            <th>报文类型</th>
            <th>具体代码</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="2">询问报文</td>
            <td>0或8</td>
            <td>回送（Echo）请求或应答</td>
            <td>-</td>
        </tr>
        <tr>
            <td>13或14</td>
            <td>时间戳（Timestamp）请求或应答</td>
            <td>-</td>
        </tr>
    </tbody>
</table>

#### 路由

##### 自治系统（Autonomous System）

一个自治系统（AS）是处于一个管理机构下的网络设备群
AS内部网络自行管理，AS对外提供一个或者多个出（入）口

自治系统内部路由的协议称为：内部网关协议（RIP，OSPF）
自治系统外部路由的协议称为：外部网关协议（BGP）



###### RIP协议(Routing Information Protocol)

RIP协议把网络的跳数（hop）作为DV算法的距离
RIP协议每隔30秒交换一次路由信息
RIP协议认为`跳数>15`的路由则为不可达路由

RIP协议的缺点是故障信息传递慢


> 距离矢量（DV）算法

每一个节点使用两个向量D<sub>i</sub>和S<sub>i</sub>
D<sub>i</sub>描述的是当前节点到别的节点的距离
S<sub>i</sub>描述的是当前节点到别的节点的下一节点
每一个节点与相邻的节点交换向量D<sub>i</sub>和S<sub>i</sub>的信息
每一个节点根据交换的信息更新自己的节点信息


 > RIP协议的过程
 
 1.路由器初始化路由信息（两个向量D<sub>i</sub>和S<sub>i</sub>）
 2.对相邻路由器X发过来的信息的内容进行修改（下一跳地址设置为X，所有距离加1）
 3.检索本地路由，将信息中新的路由插入到路由表里面
 4.检索本地路由，对于下一跳为X的，更新为修改后的信息
 5.检索本地路由，对比相同目的的距离，如果新信息的距离更小，则更新本地路由表
 6.如果3分钟没有收到相邻的路由信息，则把相邻路由设置为不可达（16跳）


###### OSPF协议

> Dijkstra算法（以起始点为中心，向外层层扩展）

1.初始化两个集合（S，U）（S为只有初始顶点点A的集合，U为其他顶点集合）
2.如果U不为空，对U集合顶点进行距离的排序，并取出距离A最近的一个顶点D
3.将顶点D纳入S集合
4.更新通过顶点D到达U集合所有点的距离（如果距离更小则更新，否则不更新）
5.重复2，3，4步骤
6.直到U集合为空，算法完成


> 链路状态（LS）协议

向所有的路由器发送消息
消息描述该路由器与相邻路由器的链路状态
只有链路状态发生变化时，才发送更新信息



> OSPF（Open Shortest Path First）协议的过程


```
flowchart TD
id1[路由器接入网络] 
id2[随后向相邻路由器发出问候信息] 
id3[与相邻路由器交流链路状态数据库] 
id4[广播和更新未知路由]



id1 --> id2 --> id3 --> id4 

```




> OSPF五种消息类型

问候消息（Hello）
链路状态数据库的描述信息
链路状态请求信息
链路状态更新信息
链路状态确认信息


###### RIP与OSPF的对比

| RIP协议 | OSPF协议 |
| ---- | ----- |
| 从邻居看网络 | 整个网络的拓扑 |
| 在路由之间累加距离 | Dijkstra算法计算最短路径 |
| 频繁，周期更新，收敛很慢 | 状态变化更新，收敛很快 |
| 路由间拷贝路由信息 | 路由间传递链路状态，自行计算路径 |



###### BGP协议

BGP协议是运行在AS之间的一种协议
BGP协议能够找到一条到达目的地`比较好`的路由
BGP并不关心内部网络的拓扑
AS之间通过`BGP发言人（speaker）`交流信息
`BGP发言人（speaker）`可以人为配置策略


### 传输层

用`端口`来标记不同的网络进程，端口使用`16bit`表示，范围就是`0-65535`


#### UDP（User Datagram Protocol）协议


`数据报（Datagram）`指的是`应用层`所传输过来的一个完整的数据

| UDP的特点 |
| ---- |
| 无连接协议 |
| 不能保证可靠的交付数据 |
| 面向报文传输 |
| 没有拥塞控制 | 
| 首部开销很小 |


##### UDP首部

<table>
    <thead>
        <tr>
            <th colspan="2">UDP首部</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>16bit（位）源端口号</td>
            <td>16bit（位）目的端口号</td>
        </tr>
        <tr>
            <td>16bit（位）UDP长度</td>
            <td>16bit（位）UDP校验和</td>
        </tr>
    </tbody>
</table>

> UDP长度是包括UDP数据的，这个长度的最小值就是`8B`，`8B`就是仅包括UDP的首部

#### TCP（Transmission Control Protocol）协议

| TCP的特点 |
| ------ |
| 面向连接的协议 |
| 一个连接有两端（点对点通信）|
| 提供可靠的传输服务 |
| 提供`全双工`的通信 | 
| 面向字节流的协议  |


##### TCP首部


<table>
    <thead>
        <tr>
            <th colspan="6">TCP首部</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="3">16bit（位）源端口</td>
            <td colspan="3">16bit（位）目的端口</td>
        </tr>
        <tr>
            <td colspan="6">32bit（位）序号</td>
        </tr>
        <tr>
            <td colspan="6">32bit（位）确认号</td>
        </tr>
        <tr>
            <td colspan="1">4bit（位）数据偏移</td>
            <td colspan="1">6bit（位）保留字段</td>
            <td colspan="1">6bit（位）TCP标记</td>
            <td colspan="3">16bit（位）窗口</td>
        </tr>
        <tr>
            <td colspan="3">16bit（位）校验和</td>
            <td colspan="3">16bit（位）紧急指针</td>
        </tr>
        <tr>
            <td colspan="5">TCP选项（可选）</td>
            <td colspan="1">填充</td>
        </tr>
    </tbody>
</table>

###### 序号

因为我们知道`TCP`协议是面向字节流的，因此对于`TCP协议`来说，每一个字节都有一个唯一的序号，这个序号代表的是，这一个`TCP报文`所传输数据的首字节序号

###### 确认号

确认号也是一个字节一个序号，代表期望收到数据的首字节序号
假设确认号为`N`，则表示`N-1`序号的数据都已经收到

###### 数据偏移

单位为`32位字`，真实的TCP的数据所偏离首部的距离。这个是由`TCP选项`的内容所导致的，因为这个选项我们不知道选项的内容有多少，所以这里我们需要存储数据偏移，以表达说真实的数据，偏离头部的位置。

###### TCP标记



| 标记| 含义 | 备注 |
| ---- | ----|  ---- |
| `URG`(Urgent) | 紧急位 | 如果`URG=1`表示紧急数据 |
| `ACK`(Acknowledgement) |  确认位 | 如果`ACK=1`确认号才生效 |
| `PSH`(Push) | 推送位 | 如果`PSH=1`表示尽快地把数据交付给应用层 |
| `RST`(Reset) | 重置位 |如果`RST=1`表示重新建立连接 |
| `SYN`(Synchronization) | 同步位 | 如果`SYN=1`表示连接请求报文 |
| `FIN`(Finish) | 终止位 | 如果`FIN=1`表示释放连接 |


###### 窗口

窗口指明允许对方发送的数据量

###### 紧急指针

当`URG=1`时才启用，指定紧急数据在报文的位置


##### 可靠传输的基本原理

###### 停止等待协议

停止等待协议是最简单的可靠传输协议，它通过`超时重传`来保证可靠传输，但是它对信道的利用效率不高



首先发送方建立起一个TCP的数据，发送给接收方，经过一段时间，接收方接收到消息，发送一个确认消息给发送方，经过一段时间，发送方收到确认消息，生成新数据发送给接收方，以此类推，如果发送方发送数据，没有收到接收方的确认消息，就会重新发送这个数据。

| 停止等待协议出差错的情况 |
| --- |
|  发送的消息在路上丢失了 |
| 确认的消息在路上丢失了 | 
| 确认的消息很久才到 |



###### 连续ARQ（Automatic Repeat reQuest）协议

| 1 | 2|3|4|5|6|7|8|9|10|11|12|
| --- |--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |--- |

假设，首先连续发送6个报文，收到了1和2这两个报文的确认消息，这时会把`滑动窗口`向前移动两个位置，发送7和8这两个报文，等新的确认消息到达，在把`滑动窗口`向前移动，但是
如果每个报文都进行确认，开销很大，所以采用`累计确认`的方式，如果连续发送6个报文，收到了5的确认消息，就说明前5个报文都收到了，这时会把`滑动窗口`向前移动，发送7到11的报文



##### TCP协议的可靠传输

TCP协议的可靠传输基于连续ARQ协议
TCP的`滑动窗口`以字节为单位



##### TCP协议的流量控制

接收方希望发送方把数据发送的慢一些，让发送方发送速率不要太快。
它使用`滑动窗口`实现，通过窗口大小控制对方发送速率。

##### TCP协议的拥塞控制

拥塞控制考虑整个网络，是全局性的考虑
如果发送报文超时则认为网络发生了拥塞

###### 慢启动算法

由小到大逐渐增加发送数据量
每收到一个报文确认，就加一
发送报文的数量是指数增长的，增长到`慢启动阈值`就不增长了，进行`拥塞避免算法`

###### 拥塞避免算法

维护一个拥塞窗口的变量，这个变量是大于`慢启动阈值`的
只要网络不拥塞，就试探着将拥塞窗口调大

##### TCP连接的建立

 首先发送方发送报文，这时`SYN=1`，`seq=x`，`seq`是自己的序列号
 
 接收方在接收到这个报文之后会被动打开`TCP连接`并发送一个连接，这时报文里有`SYN=1`，`ACK=1`，`seq=y`，`ack=x+1`
 
 在发送方接收到接收方所发出的消息之后也会进行一个回应，这时报文里有`ACK=1`，`seq=x+1`，`ack=y+1`
 
 
在三次握手之中，发送方有两个状态，`同步已发送`，`建立连接`。接收方有三个状态，`监听`，`同步已接收`，`建立连接`。只有在双方都到达`建立连接`状态，就可以进行数据的传输了。



##### TCP连接的释放

发送方发送一个报文，这时报文里有`FIN=1`，`seq=u`，发送了这个报文之后就进入了`FIN-WAIT-1`状态

接收方收到发送方发送的报文后，也会发送一个报文进行确认，这时报文里有`ACK=1`，`seq=v`，`ack=u+1`。并且接收方进入到`关闭等待状态`，但是还可以发送数据。

当发送方收到接收方回应的报文之后就进入到了`FIN-WAIT-2`状态

等到接收方数据发送完成之后又会发送一个报文，这时报文里有`FIN=1`，`ACK=1`，`seq=w`，`ack=u+1`，并进入到`最后确认`状态，收到发送方的第二次报文后进入`关闭状态`

当发送方收到接收方发送的第二次报文之后又会发出一个确认报文，这时报文里有`ACK=1`，`seq=u+1`，`ack=w+1`，并进入到`时间等待状态`，等待一段时间确保没有出现问题然后进入`关闭状态`



##### TCP的定时器

| TCP的定时器 | 解释 |
| ----- | ----- |
| 超时定时器 |  每发送一个消息都需要设置一个定时器 |
| 坚持定时器 | 当发送方接收到窗口为`0`的消息，则启动坚持定时器<br>坚持定时器每隔一段时间发送一个窗口探测报文<br>解决`死锁`的问题 |
| 等待计时器 | 等待计时器会等待`2MSL`（Max Segment Lifetime）的时间 |

> 死锁的意思是，在TCP协议的流量控制中，接收方在通知发送方窗口调整的消息时，在网络传输的过程中发生丢失，发送方会一直等待（因为发送方还是以为接收方的窗口为`0`），接收方已经把窗口调整的消息发送了，因此接收方也会一直的等待，所以因为窗口调整的消息丢失，导致发送方和接收方都在相互等待，就形成了`死锁`。


> `MSL`的意思是最长报文段寿命

> 等待计时器的第一个功能是，确保发送方的最后一个报文可以到达接收方，如果接收方在`2MSL`时间内没有收到，则接收方会重发第二次报文给发送方，等待计时器的第二个功能是确保当前连接的所有报文都已经过期了


### 应用层

#### DNS

`DNS`（Domain Name System：域名系统）


```
graph TB
域名--> |DNS服务| IP
```

域名由`.` `字母` `数字`组成，`.`分割不同的域



| 域名分类 |
| ----- |
| 顶级域 |
| 二级域 |
| 三级域 |



#### DHCP协议

`DHCP`是一个局域网协议

`DHCP`是应用`UDP`协议的应用层协议，它的作用是为这些临时加入局域网的设备提供一个临时的`IP`地址


#### HTTP协议


`HTTP`协议是可靠的数据传输协议


##### 浏览器输入URL后HTTP请求返回的完整过程

```
start=>start: Redirect（跳转）
operation=>operation: App cache（应用缓存）
operation1=>operation: DNS（DNS查找）
operation2=>operation: TCP（创建TCP连接）
operation3=>operation: Request（发送请求）
end=>end: Response（接收响应）


start->operation
operation->operation1
operation1->operation2
operation2->operation3
operation3->end
```


##### URI(Uniform Resource Identifier)

统一资源标志符
用来唯一标识互联网上的信息资源
包括`URL`和`URN`

##### URL(Uniform Resource Locator)

统一资源定位器
格式为`http://user:pass@host.com:80/path?query=string#hash`

##### URN

永久统一资源定位符
在资源移动之后还能被找到

##### CORS


```
const http = require('http')
    
http.createServer(function (request, response) {
    console.log('request come', request.url)
    response.writeHead(200, {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': '',
        'Access-Control-Allow-Methods': 'PUT,Delete',
        'Access-Control-Max-Age': '1000' // 意思是1000秒之内，不需要在发送预请求来验证了，可以直接发送正式的请求
    })
    response.end('Hello World!')
}).listen(8888)
```



##### Cookie

服务端返回数据的时候通过`Set-Cookie`这个头设置它保存在浏览器里面的内容
`Cookie`在下次请求时会自动带上
`Cookie`是键值对的形式来保存的，它可以设置多个


```
const http = require('http')
    
http.createServer(function (request, response) {
    console.log('request come', request.url)
    if ( request.url === '/' ) {
        const html = fs.readFileSync( 'test.html', 'utf8' )
        response.writeHead(200, {
            'Content-Type': 'text/html',
            'Set-Cookie': 'id=123'
        })
        response.end( html )
    }
}).listen(8888)
```

##### 数据协商

在客户端发送给服务端一个请求的时候，客户端会声明我希望这个请求我拿到的数据格式以及数据相关的一些限制

|  请求头 | 含义 |
| ---- | --- | 
| `Accept` | 指定的是我想要的数据类型 |
|  `Accept-Encoding` | 数据是怎样的编码方式，进行一个数据的传输 |
| `Accept-Language`  | 根据这个头去判断返回的语言 |
| `User-Agent`  | 用来表示浏览器的相关信息 |
| `Content-Type` | 对应`Accept`，选择一个数据格式进行返回 |
| `Content-Encoding`  | 对应`Accept-Encoding`，服务端用的什么数据压缩方式|
| `Content-Language` | 是否根据请求返回了想要的语言 |


##### Redirect

```
const http = require('http')
    
http.createServer(function (request, response) {
    if (request.url === '/') {
        response.writeHead(302, {
            'Location': '/new'
        })
        response.end('')
    }
    if (request.url === '/new') {
        response.writeHead(200, {
            'Content-Type': 'text/html'
        })
        response.end('<div>this is content</div>')
    }
}).listen(8888)
```

##### HTTP请求方法

| `HTTP`请求方法 |
| ------ |
| `GET` |
| `POST` |
| `DELETE` |
| `UPDATE` |
| `PUT` |
| `OPTIONS` |
| `PATCH` |
| `HEAD` |
| `TRACE` | 

###### POST和GET

| GET | POST |
| ---- | ---- |
| 在浏览器回退时是无害的 | 在浏览器回退时会再次请求 |
| 产生的`URL`地址可以被收藏 | 产生的`URL`地址不可以被收藏 |
| 请求会被浏览器主动缓存（通过加时间戳解决） | 不会有缓存问题，除非手动设置 |
| 只能进行`URL`编码 | 支持多种编码方式 |
| 请求参数会被完整保留在浏览器历史记录里 | 请求参数不会被保留 |
| 对参数的数据类型只接受`ASCII`字符| 没有限制 |
| 请求在`URL`中传送的参数是有长度限制的| 没有限制 |
| 不安全（因为参数直接暴露在`URL`上） | |
| 参数通过`URL`传递 | 参数放在`Request Body`中 |
| 传输中文时会产生乱码需要通过`encodeURI`进行编码|  传递中文时没有乱码 |



##### Content-Security-Policy

限制资源获取
报告资源获取越权

###### 限制方式

通过`default-src`限制全局的所有跟链接请求有关的作用范围
根据特定资源类型来限制资源范围

> 通过服务器端设置

```
// test.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    
</head>
<body>
    <div>This is content</div>
    <script type="text/javascript">
        console.log('inline js')
    </script>
</body>
</html>
```

```
const http = require( 'http' )
const fs = require( 'fs' )
    
http.createServer(function (request, response) {
    const html = fs.readFileSync( 'test.html', 'utf-8' );
    response.writeHead(200, {
        'Content-Type': 'text/html',
        // 我们只能通过http或者https的方式进行加载，所以上面的内联脚本将不会加载
        'Content-Security-Policy': 'default-src http: https:'
    })
    response.end( html )
}).listen(8888)
```

> 通过客户端设置

```
// test.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src http: https:">
    <title>Document</title>
    
</head>
<body>
    <div>This is content</div>
    <script type="text/javascript">
        console.log('inline js')
    </script>
</body>
</html>
```

##### HTTP2

在`HTTP1.1`中，我们发送请求，在`TCP`连接上发送数据，是必需要一个请求发送完成之后，然后在发第二个请求，同时服务端返回，也是先要把前一个请求的数据全部返回了之后，才能返回第二个数据。

在`HTTP2`中，得益与`信道复用`和`分帧传输`的功能，让我们在`HTTP2`中在同一个连接上面，可以去并发的发送不同的请求。



###### 分帧传输

在`HTTP2`中，数据的传输是分帧进行传输的，每一帧都有一个上下文的联系。我们传输的一个数据并不需要一定要按照连续的顺序去发送，而是可以分成不同的帧一起进行发送。在把数据接收完之后，根据帧信息里面包含着的一个先后的顺序，进行一个组合，拿到一个真正的数据。



###### `Server Push`


```
const http = require( 'http' )
const fs = require( 'fs' )
    
http.createServer(function (request, response) {
    const html = fs.readFileSync( 'test.html', 'utf-8' );
    const img = fs.readFileSync('test.jpg')
    if ( request.url === '/' ) {
        response.writeHead(200, {
            'Content-Type': 'text/html',
            // Link这个头是HTTP2中可以指定这个请求我想要推送哪些内容
            'Link': '</test.jpg>;as=image;rel=preload'
        })
        response.end( html )
    } else {
        response.writeHead(200, {
            'Content-Type': 'image/jpg'
        })
        response.end( img )
    }
}).listen(8888)
```


#### HTTPS协议

`HTTPS协议`是安全的`HTTP协议`


##### HTTPS工作过程

```
start=>start: 443端口的TCP连接
operation=>operation: SSL安全参数握手
operation1=>operation: 客户端发送数据
operation2=>operation: 服务端发送数据


start->operation
operation->operation1
operation1->operation2
```






##### 加密模型

对称加密（两个秘钥一致）
非对称加密（两个秘钥不一致，是一组秘钥）

##### 数字证书

数字证书是可信任组织颁发给特定对象的认证

|数字证书 |
| ----- |
| 证书格式，版本号 |
| 证书序列号 |
| 签名算法 |
| 有效期 |
| 对象名称 |
| 对象公开秘钥 |
| ... |



##### SSL（Secure Sockets Layer：安全套接层）

提供数据安全和数据完整的服务，以及对传输层数据进行加密后传输


###### SSL安全参数握手过程

客户端生成随机数1，然后把随机数，协议版本，加密算法，传输给服务端
服务端生成随机数2，提供自己的数字证书，确定加密算法，传输给客户端
客户端确认证书是否有效，生成随机数3，使用服务器的公钥加密随机数3，传输给服务端
服务端根据之前所约定的加密算法，根据1，2，3三个随机数生成对称秘钥













