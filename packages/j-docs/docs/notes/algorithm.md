# 算法

## 时间复杂度与空间复杂度

::: tip
时间复杂度算的是运行的次数<br/>
空间复杂度算的是占用的内存
:::


| 描述 | 增长数量级|
| ------ | ----- |
| 常数级别  | 1 |
| 对数级别 |  logN |
| 线性级别 | N | 
| 线性对数级别 | NlogN |
| 平方级别 | N² |
| 立方级别 | N³ |
| 指数级别 | 2^N |

## 排序


| 算法 | 是否稳定 |  是否为原地排序 | 时间复杂度 | 空间复杂度 | 备注 |
| ---- | ---- | ----- | ----- | ----- | ----- |
| 选择排序  |  否 | 是 | N² | 1  | |
| 插入排序 | 是 | 是 |  介于N和N²之间 | 1 | 取决于输入元素的排列情况 | 
| 希尔排序 | 否 | 是 | | 1 | |
| 快速排序 | 否 | 是 | NlogN | lgN | 运行效率由概率提供保证 |
| 归并排序 | 是 | 否 | NlogN | N | |
| 堆排序 | 否 | 是 | NlogN | 1 | |



### 选择排序

::: tip
运行时间和输入无关<br/>
数据移动是最少的
:::

::: details 思路
首先找到数组中最小的那个元素将它和数组的第一个元素交换位置<br/>
再次在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置<br/>
如此往复，直到将整个数组排序
:::


```js
class Selection {

    sort (a) {

        let N = a.length 

        for ( let i = 0; i < N; i++ ) {
            let min = i
            for (let j = i + 1; j < N; j++) {
                if ( this.less( a[j], a[min] ) ) {
                    min = j
                }
            }
            this.exch( a, i, min )
        }
    }

    less ( v, w ) {
        return v < w
    }

    exch ( a, i, j ) {
        let temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

::: details 为什么选择排序不稳定呢?
假设有一个待排序的序列`2 3 2 1 4`<br/>
我们知道第一次排序后就会选择`第1个元素2`和`元素1`交换，那么原来序列中`两个2`的相对顺序就被破坏了
:::

