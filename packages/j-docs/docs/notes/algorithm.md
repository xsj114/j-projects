# 算法

## 时间复杂度与空间复杂度

::: tip
时间复杂度算的是运行的次数<br/>
空间复杂度算的是占用的内存
:::


| 描述 | 增长数量级|
| ------ | ----- |
| 常数级别  | 1 |
| 对数级别 |  logN |
| 线性级别 | N | 
| 线性对数级别 | NlogN |
| 平方级别 | N² |
| 立方级别 | N³ |
| 指数级别 | 2^N |

## 排序


| 算法 | 是否稳定 |  是否为原地排序 | 时间复杂度 | 空间复杂度 | 备注 |
| ---- | ---- | ----- | ----- | ----- | ----- |
| 选择排序  |  否 | 是 | N² | 1  | |
| 冒泡排序 | 是 | 是 | N² | 1 | |
| 插入排序 | 是 | 是 |  介于N和N²之间 | 1 | 取决于输入元素的排列情况 | 
| 希尔排序 | 否 | 是 | | 1 | |
| 快速排序 | 否 | 是 | NlogN | lgN | 运行效率由概率提供保证 |
| 归并排序 | 是 | 否 | NlogN | N | |
| 堆排序 | 否 | 是 | NlogN | 1 | |



### 选择排序

::: tip
运行时间和输入无关<br/>
数据移动是最少的
:::

::: details 思路
首先找到数组中最小的那个元素将它和数组的第一个元素交换位置<br/>
再次在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置<br/>
如此往复，直到将整个数组排序
:::


```js
class Selection {

    sort (a) {

        let N = a.length 

        for ( let i = 0; i < N; i++ ) {
            let min = i
            for (let j = i + 1; j < N; j++) {
                if ( this.less( a[j], a[min] ) ) {
                    min = j
                }
            }
            this.exch( a, i, min )
        }
    }

    less ( v, w ) {
        return v < w
    }

    exch ( a, i, j ) {
        let temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

::: details 为什么选择排序不稳定呢?
假设有一个待排序的序列`2 3 2 1 4`<br/>
我们知道第一次排序后就会选择`第1个元素2`和`元素1`交换，那么原来序列中`两个2`的相对顺序就被破坏了
:::


### 冒泡排序


::: details 思路
比较相邻的元素<br/>
如果第一个比第二个大，就交换他们两个<br/>
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对<br/>
这步做完后，最后的元素会是最大的数<br/>
针对所有的元素重复以上的步骤，除了最后一个<br/>
持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较
::: 

```js
class Bubble {

    sort (a) {

        let N = a.length 

        for ( let i = N - 1; i > 0; i-- ) {
            for ( let j = 0 ; j < i; j++ ) {
                if ( !this.less( a[j], a[j+1] ) ) {
                    this.exch( a, j, j + 1 )
                }
            }
        }
    }

    less ( v, w ) {
        return v < w
    }

    exch ( a, i, j ) {
        let temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

### 插入排序

::: tip
所需的时间取决于输入中元素的初始顺序<br/>
插入排序对于部分有序的数组十分高效，也很适合小规模数组
:::


::: details 思路
将当前元素和前一个元素做比较<br/>
如果小于前一个元素则交换位置<br/>
并将交换好位置的元素和它前一个元素做比较,直到此元素不小于前一个元素<br/>
当遍历完整个数组，排序完成
:::

```js
class Insertion {

    sort ( a ) {
        let N = a.length;
        for ( let i = 0; i < N; i++ ) {
            for ( let j = i; j > 0 && this.less( a[j], a[j-1] ); j-- ) {
                this.exch( a, j, j - 1 )
            }
        }
    }

    less ( v, w ) {
        return v < w
    }

    exch ( a, i, j ) {
        let temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

::: info
要大幅度提高插入排序的速度<br/>
只需要在内循环中将较大的元素都向右移动而不总是交换两个元素
:::

```js

```
