---
title: RESTful
titleTemplate: 学习笔记
---

[toc]

# RESTful API


| `RESTful API`包含 |
| --- |
| 基本的`URI`，如`https://api.github.com/users` |
| 标准`HTTP`方法如`GET`，`POST`，`PUT`，`PATCH`，`DELETE` |
| 传输的数据媒体类型如`JSON`，`XML` |


## REST

`REST`（Representational State Transfer）是`万维网软件架构风格`用来创建网络服务<br/>

`Representational`是数据的表现形式（`JSON`，`XML`....）<br/>
`State`是当前状态或者数据<br/>
`Transfer`是数据传输

| REST的6个限制 | 描述 |
| ------- | ------ |
| 客户-服务器(Client-Server) | 关注点分离<br>服务端专注数据存储提升了简单性<br>前端专注用户界面提升了可移植性 |
| 无状态 | 所有用户会话信息都保存在客户端<br>每次请求必须包括所有信息不能依赖上下文信息<br>服务端不用保存会话信息提升了简单性，可靠性，可见性|
| 缓存 | 所有服务端响应都要被标为可缓存或不可缓存<br>减少前后端交互提升了性能|
| 统一接口 | 接口设计尽可能统一通用，提升了简单性，可见性 <br> 接口与实现解耦，使前后端可以独立开发迭代|
| 分层系统 | 软件架构是分层的，每层只知道相邻的一层，后面隐藏的就不知道了，比如客户端不知道是和代理还是真实服务器通信|
| 按需代码| 客户端可以下载运行服务端传来的代码，比如JS<br>通过减少一些功能简化了客户端 |



### 统一接口的限制

| 统一接口的限制 |  描述 |
| ---------- | ----- |
| 资源的标识 | 资源是任何可以命名的事物，比如用户，评论等<br>每个资源可以通过`URI`被唯一地标识 |
| 通过表述来操作资源 |表述就是`Representation`<br>客户端不能直接操作服务端资源(比如`SQL`)<br>客户端应该通过表述来操作资源（比如`JSON`） |
| 自描述消息 | 每个消息（请求或响应）必须提供足够的信息让接受者理解，例如媒体类型，`HTTP`方法，是否缓存 |
|超媒体作为应用状态引擎 | 超媒体指带文字的链接<br>应用状态指一个网页<br>引擎指驱动，跳转<br>合起来就是点击链接跳转到另一个网页 |


## RESTful API设计最佳实践


### 请求设计规范


| 请求设计规范 | 例子 |
| ----- | ----- |
| `URI`使用名词，尽量用复数 | `/users` |
| `URI`使用嵌套表示关联关系 | `/users/12/repos/5` |
| 使用正确的`HTTP`方法| `GET`，`POST`，`PUT`，`DELETE` |
| 不符合`CRUD`（增删改查）的情况 | `POST`<br>`action`<br>`子资源` |


### 响应设计规范

| 响应设计规范 | 解释 |
|  ----- |  ----- |
| 查询 |  每个响应都是可以被查询，可以被过滤的，我们加上一些限制条件就只能返回符合这些条件的一些返回值了 |
| 分页 | 如果列表特别长的话，我们应该加上分页信息 |
| 字段过滤 | 返回的结果只能返回你指定的那几个字段 |
| 状态码 | 选择正确的状态码来作为它的响应  |
| 错误处理 | 如果请求是错的，应该尽量把错误信息给返回并按照一个规范的格式 |



### 增删改查应该返回什么响应

`增`返回当前增加或修改的数据<br/>
`删`返回`204`状态码<br/>
`改`返回当前增加或修改的数据<br/>
`查`返回查询的数据



